# 19-Bit CPU Architecture - Complete Verilog Implementation

## Architecture Overview

This is a specialized 19-bit CPU designed for signal processing and cryptography applications. The architecture features a 5-stage pipeline with dedicated instructions for FFT operations and encryption/decryption.

## Key Features
- 19-bit instruction width
- 16 general-purpose registers (R0-R15)
- 5-stage pipeline (IF, ID, EX, MEM, WB)
- Specialized DSP and cryptographic instructions
- Hazard detection and forwarding unit
- Compatible with EDA Playground

## Instruction Format

```
Bit Layout: [18:15] [14:11] [10:7] [6:3] [2:0]
            OPCODE   RS1    RS2   RD/IMM FUNC
```
Abbrevations and its full forms with its funcitons :
PC = Program Counter
IF = Instruction Fetch 

ID = Instruction Decode 
EX = Execute 

MEM = Memory Access 

WB = Write Back 

if_id_pc = Program Counter stored between Instruction Fetch and Instruction Decode stages.

if_id_instr = Instruction fetched, stored between Instruction Fetch and Instruction Decode.

id_ex_pc = Program Counter passed from Decode → Execute.

id_ex_rs1_data = Source Register 1 data passed from Decode → Execute.

id_ex_rs2_data = Source Register 2 data passed from Decode → Execute.

id_ex_imm = Immediate value (sign-extended) passed Decode → Execute.

id_ex_rs1 = Source Register 1 index between Decode → Execute.

id_ex_rs2 = Source Register 2 index between Decode → Execute.

id_ex_rd = Destination Register index between Decode → Execute.

id_ex_opcode = Current Instruction Opcode between Decode → Execute.

id_ex_func = Function field (ALU operation specifics) between Decode → Execute.

id_ex_reg_write = Signal controlling whether a register write will happen.

id_ex_mem_read = Whether memory read happens ( LD instruction).

id_ex_mem_write = Whether memory write happens (ST instruction).

id_ex_mem_to_reg = Whether WB stage writes memory output to registers.

ex_mem_pc = Program Counter passed Execute → Memory.

ex_mem_alu_result = ALU computation result passed Execute → Memory.

ex_mem_rs2_data = Second operand data (needed for store) passed Execute → Memory.

ex_mem_rd = Destination register index passed Execute → Memory.

ex_mem_reg_write = Register write enable signal for WB stage.

ex_mem_mem_read = Memory read signal passed Execute → Memory.

ex_mem_mem_write = Memory write signal passed Execute → Memory.

ex_mem_mem_to_reg = Control signal: select memory data → register file.

mem_wb_pc = Program Counter passed Memory → Write Back.

mem_wb_alu_result = ALU result passed Memory → Write Back.

mem_wb_mem_data = Data loaded from memory passed Memory → Write Back.

mem_wb_rd = Destination register index passed Memory → Write Back.

mem_wb_reg_write = Register write enable signal in WB stage.

mem_wb_mem_to_reg = Selects whether WB uses memory data vs ALU result.


stall = Pipeline stall signal (pauses IF/ID stage to avoid hazards).

flush = Flush signal (insert NOP instruction after branch/jump).

forward_a = Forwarding selector for ALU input A (handles data hazard).

forward_b = Forwarding selector for ALU input B (handles data hazard).


Your instruction is split like this:

instr[18:15] → opcode = Main operation code (ADD, SUB, LD, etc.).

instr[14:11] → rs1 = Source register 1 index.

instr[10:7] → rs2 = Source register 2 index.

instr[6:3] → rd = Destination register index.

instr[2:0] → func = Function sub-field (e.g., ADD/SUB variant).

Memory and Bus Signals
instr_mem_addr = Instruction memory address (from PC).

instr_mem_data = Instruction fetched from instruction memory.

data_mem_addr = Address for data memory (load/store location).

data_mem_write_data = Data to be written into memory (for store).

data_mem_read_data = Data read from memory (for load).

data_mem_read = Control signal → "1" when reading from memory.

data_mem_write = Control signal → "1" when writing to memory.


registers[0:15] = 16 General Purpose Registers (each 19 bits).

R0 = Usually constant zero register (by convention).

R1–R15 = General-purpose registers for operands/results.



fft_operation(data) = Simplified FFT butterfly computation.

encrypt_operation(data) = Simplified XOR-based encryption.

decrypt_operation(data) = Inverse of encryption.


clk = Clock signal.

reset = Synchronous reset.

$dumpfile, $dumpvars = Verilog system tasks for waveform dump.

$display = Print simulation info to console.




